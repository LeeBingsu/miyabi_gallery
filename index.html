<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>MiyGal</title>
    <link rel="icon" type="image/x-icon" href="/favicon.ico">
    <link rel="icon" type="image/png" sizes="32x32" href="/favicon-32x32.png">
    <link rel="icon" type="image/png" sizes="16x16" href="/favicon-16x16.png">
    <link rel="apple-touch-icon" sizes="180x180" href="/apple-touch-icon.png">

    <!-- zip.js Library with Password Support -->
    <script src="https://unpkg.com/@zip.js/zip.js@2.7.72/dist/zip-full.min.js"></script>
    
    <!-- Hammer.js for swipe gestures -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/hammer.js/2.0.8/hammer.min.js"></script>

    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
            -webkit-tap-highlight-color: transparent;
        }

        :root {
            --primary-color: #007AFF;
            --secondary-color: #5856D6;
            --background: #F2F2F7;
            --card-background: #FFFFFF;
            --text-primary: #000000;
            --text-secondary: #8E8E93;
            --border-color: #E5E5EA;
            --destructive: #FF3B30;
            --success: #34C759;
            --radius-large: 20px;
            --radius-medium: 12px;
            --radius-small: 8px;
            --shadow: 0 2px 16px rgba(0, 0, 0, 0.08);
            --shadow-hover: 0 8px 24px rgba(0, 0, 0, 0.12);
        }

        @media (prefers-color-scheme: dark) {
            :root {
                --background: #000000;
                --card-background: #1C1C1E;
                --text-primary: #FFFFFF;
                --text-secondary: #8E8E93;
                --border-color: #38383A;
            }
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'SF Pro Display', 'Segoe UI', Roboto, sans-serif;
            background: var(--background);
            color: var(--text-primary);
            padding: 0;
            min-height: 100vh;
        }

        .viewing-area {
            padding: 40px 16px 16px;
            text-align: center;
        }

        h1 {
            font-size: 28px;
            font-weight: 700;
            letter-spacing: -0.5px;
            margin-bottom: 8px;
        }

        .subtitle {
            font-size: 15px;
            color: var(--text-secondary);
            font-weight: 400;
        }

        .interaction-area {
            max-width: 100%;
            margin: 0 auto;
            padding: 0 16px 40px;
        }

        .card {
            background: var(--card-background);
            border-radius: var(--radius-large);
            padding: 16px;
            margin-bottom: 16px;
            box-shadow: var(--shadow);
        }

        .breadcrumb {
            display: flex;
            align-items: center;
            gap: 8px;
            flex-wrap: wrap;
            margin-bottom: 16px;
            padding: 12px 16px;
            background: var(--background);
            border-radius: var(--radius-medium);
            font-size: 14px;
        }

        .breadcrumb-item {
            color: var(--primary-color);
            cursor: pointer;
            transition: opacity 0.2s;
        }

        .breadcrumb-item:hover {
            opacity: 0.7;
        }

        .breadcrumb-item.current {
            color: var(--text-primary);
            cursor: default;
            font-weight: 600;
        }

        .breadcrumb-separator {
            color: var(--text-secondary);
            user-select: none;
        }

        .folder-container {
            display: flex;
            gap: 8px;
            flex-wrap: wrap;
            margin-bottom: 12px;
            padding-bottom: 12px;
            border-bottom: 1px solid var(--border-color);
        }

        .folder-pill {
            padding: 10px 16px;
            background: var(--background);
            color: var(--text-primary);
            border: none;
            border-radius: 20px;
            font-size: 14px;
            font-weight: 500;
            cursor: pointer;
            transition: all 0.2s cubic-bezier(0.4, 0, 0.2, 1);
            white-space: nowrap;
        }

        .folder-pill:active {
            transform: scale(0.95);
        }

        .folder-pill.active {
            background: var(--primary-color);
            color: white;
        }

        .action-bar {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 8px;
            margin-bottom: 16px;
        }

        .btn {
            padding: 12px 16px;
            border: none;
            border-radius: var(--radius-medium);
            font-size: 14px;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.2s ease;
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 6px;
        }

        .btn:active {
            transform: scale(0.96);
        }

        .btn-primary {
            background: var(--primary-color);
            color: white;
        }

        .btn-secondary {
            background: var(--background);
            color: var(--primary-color);
        }

        .btn-destructive {
            background: var(--destructive);
            color: white;
        }

        .btn:disabled {
            opacity: 0.4;
            cursor: not-allowed;
        }

        .grid {
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(120px, 1fr));
            gap: 12px;
        }

        .thumbnail {
            aspect-ratio: 1;
            position: relative;
            border-radius: var(--radius-medium);
            overflow: hidden;
            cursor: pointer;
            transition: transform 0.2s ease;
        }

        .thumbnail:active {
            transform: scale(0.95);
        }

        .thumbnail img {
            width: 100%;
            height: 100%;
            object-fit: cover;
        }

        .thumbnail .checkbox {
            position: absolute;
            top: 8px;
            right: 8px;
            width: 24px;
            height: 24px;
            background: rgba(255, 255, 255, 0.9);
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            opacity: 0;
            transition: opacity 0.2s ease;
        }

        .thumbnail.selected .checkbox,
        .selection-mode .thumbnail .checkbox {
            opacity: 1;
        }

        .thumbnail.selected .checkbox {
            background: var(--primary-color);
            color: white;
        }

        /* Image Viewer Modal */
        .modal {
            display: none;
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.95);
            z-index: 1000;
            opacity: 0;
            transition: opacity 0.3s ease;
        }

        .modal.active {
            display: flex;
            flex-direction: column;
            opacity: 1;
        }

        .modal-header {
            padding: 16px;
            display: flex;
            justify-content: space-between;
            align-items: center;
            color: white;
        }

        .modal-close {
            background: rgba(255, 255, 255, 0.1);
            border: none;
            color: white;
            padding: 8px 16px;
            border-radius: var(--radius-small);
            cursor: pointer;
            font-size: 14px;
            font-weight: 600;
        }

        .modal-image-container {
            flex: 1;
            display: flex;
            align-items: center;
            justify-content: center;
            position: relative;
            overflow: hidden;
            touch-action: pan-y pinch-zoom;
        }

        .modal-image-wrapper {
            position: relative;
            width: 100%;
            height: 100%;
            display: flex;
            align-items: center;
            justify-content: center;
            transition: transform 0.3s cubic-bezier(0.4, 0, 0.2, 1);
        }

        .modal-image-wrapper.swiping {
            transition: none;
        }

        .modal-image {
            max-width: 100%;
            max-height: 100%;
            object-fit: contain;
            user-select: none;
        }

        .modal-nav {
            position: absolute;
            top: 50%;
            transform: translateY(-50%);
            background: rgba(255, 255, 255, 0.1);
            border: none;
            color: white;
            width: 48px;
            height: 48px;
            border-radius: 50%;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 24px;
            backdrop-filter: blur(10px);
            transition: background 0.2s ease;
        }

        .modal-nav:hover {
            background: rgba(255, 255, 255, 0.2);
        }

        .modal-nav.prev {
            left: 16px;
        }

        .modal-nav.next {
            right: 16px;
        }

        .modal-nav:disabled {
            opacity: 0.3;
            cursor: not-allowed;
        }

        .modal-footer {
            padding: 16px;
            text-align: center;
            color: white;
            font-size: 14px;
        }

        /* Progress Bar */
        .progress-container {
            position: fixed;
            bottom: 20px;
            left: 50%;
            transform: translateX(-50%);
            width: 90%;
            max-width: 400px;
            background: var(--card-background);
            border-radius: var(--radius-medium);
            padding: 16px;
            box-shadow: var(--shadow-hover);
            z-index: 2000;
            display: none;
        }

        .progress-container.active {
            display: block;
            animation: slideUp 0.3s ease;
        }

        @keyframes slideUp {
            from {
                transform: translateX(-50%) translateY(100px);
                opacity: 0;
            }
            to {
                transform: translateX(-50%) translateY(0);
                opacity: 1;
            }
        }

        .progress-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 12px;
        }

        .progress-title {
            font-size: 14px;
            font-weight: 600;
            color: var(--text-primary);
        }

        .progress-cancel {
            background: none;
            border: none;
            color: var(--destructive);
            font-size: 14px;
            font-weight: 500;
            cursor: pointer;
            padding: 4px 8px;
        }

        .progress-bar {
            width: 100%;
            height: 6px;
            background: var(--background);
            border-radius: 3px;
            overflow: hidden;
            margin-bottom: 8px;
        }

        .progress-fill {
            height: 100%;
            background: var(--primary-color);
            border-radius: 3px;
            transition: width 0.3s ease;
            position: relative;
            overflow: hidden;
        }

        .progress-fill::after {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            bottom: 0;
            right: 0;
            background: linear-gradient(
                90deg,
                transparent,
                rgba(255, 255, 255, 0.3),
                transparent
            );
            animation: shimmer 2s infinite;
        }

        @keyframes shimmer {
            0% {
                transform: translateX(-100%);
            }
            100% {
                transform: translateX(100%);
            }
        }

        .progress-text {
            font-size: 12px;
            color: var(--text-secondary);
            display: flex;
            justify-content: space-between;
        }

        .progress-status {
            font-size: 12px;
            color: var(--text-secondary);
            margin-top: 4px;
        }

        /* Background Upload Notification */
        .bg-upload-notification {
            position: fixed;
            bottom: 20px;
            right: 20px;
            background: var(--success);
            color: white;
            padding: 12px 20px;
            border-radius: var(--radius-medium);
            box-shadow: var(--shadow-hover);
            z-index: 2001;
            display: none;
            align-items: center;
            gap: 8px;
            animation: slideIn 0.3s ease;
        }

        .bg-upload-notification.active {
            display: flex;
        }

        @keyframes slideIn {
            from {
                transform: translateX(400px);
                opacity: 0;
            }
            to {
                transform: translateX(0);
                opacity: 1;
            }
        }

        .spinner {
            width: 16px;
            height: 16px;
            border: 2px solid rgba(255, 255, 255, 0.3);
            border-top-color: white;
            border-radius: 50%;
            animation: spin 1s linear infinite;
        }

        @keyframes spin {
            to {
                transform: rotate(360deg);
            }
        }

        input[type="file"] {
            display: none;
        }

        input[type="password"] {
            width: 100%;
            padding: 12px 16px;
            border: 1px solid var(--border-color);
            border-radius: var(--radius-medium);
            font-size: 15px;
            background: var(--background);
            color: var(--text-primary);
            margin-bottom: 12px;
        }

        .password-form {
            display: none;
        }

        .password-form.active {
            display: block;
        }

        .empty-state {
            text-align: center;
            padding: 60px 20px;
            color: var(--text-secondary);
        }

        .empty-state-icon {
            font-size: 64px;
            margin-bottom: 16px;
            opacity: 0.5;
        }

        .selection-info {
            position: fixed;
            bottom: 20px;
            left: 50%;
            transform: translateX(-50%);
            background: var(--card-background);
            padding: 12px 24px;
            border-radius: 20px;
            box-shadow: var(--shadow-hover);
            font-size: 14px;
            font-weight: 600;
            z-index: 999;
            display: none;
        }

        .selection-info.active {
            display: block;
        }

        @media (max-width: 768px) {
            .modal-nav {
                display: none;
            }
        }
    </style>
</head>
<body>
    <div class="viewing-area">
        <h1>üñºÔ∏è Miygal</h1>
        <p class="subtitle">Simple & Secure Image Gallery</p>
    </div>

    <div class="interaction-area">
        <div class="card">
            <div class="breadcrumb" id="breadcrumb">
                <span class="breadcrumb-item" onclick="navigateTo([])">Home</span>
            </div>

            <div class="folder-container" id="folderContainer"></div>

            <div class="action-bar">
                <button class="btn btn-primary" onclick="document.getElementById('zipInput').click()">
                    üìÅ Load ZIP
                </button>
                <button class="btn btn-secondary" onclick="downloadCurrentFolder()" id="downloadBtn" disabled>
                    üíæ Download
                </button>
            </div>

            <div class="action-bar">
                <button class="btn btn-secondary" onclick="toggleSelection()" id="selectBtn" disabled>
                    ‚úì Select
                </button>
                <button class="btn btn-destructive" onclick="deleteSelected()" id="deleteBtn" disabled style="display: none;">
                    üóëÔ∏è Delete Selected
                </button>
            </div>

            <input type="file" id="zipInput" accept=".zip" onchange="handleZipUpload(event)">

            <div class="password-form" id="passwordForm">
                <input type="password" id="passwordInput" placeholder="Enter ZIP password">
                <button class="btn btn-primary" onclick="unlockZip()" style="width: 100%;">
                    üîì Unlock
                </button>
            </div>

            <div class="grid" id="imageGrid"></div>
            <div class="empty-state" id="emptyState">
                <div class="empty-state-icon">üì¶</div>
                <p>No images yet</p>
                <p style="font-size: 13px; margin-top: 8px;">Load a ZIP file to get started</p>
            </div>
        </div>
    </div>

    <div class="selection-info" id="selectionInfo">
        <span id="selectionCount">0</span> selected
    </div>

    <!-- Image Viewer Modal -->
    <div class="modal" id="imageModal">
        <div class="modal-header">
            <span id="modalImageName"></span>
            <button class="modal-close" onclick="closeModal()">Close</button>
        </div>
        <div class="modal-image-container" id="modalImageContainer">
            <button class="modal-nav prev" id="prevBtn" onclick="navigateImage(-1)">‚Äπ</button>
            <div class="modal-image-wrapper" id="modalImageWrapper">
                <img id="modalImage" class="modal-image" alt="Viewing image">
            </div>
            <button class="modal-nav next" id="nextBtn" onclick="navigateImage(1)">‚Ä∫</button>
        </div>
        <div class="modal-footer">
            <span id="modalImageCount"></span>
        </div>
    </div>

    <!-- Progress Bar -->
    <div class="progress-container" id="progressContainer">
        <div class="progress-header">
            <span class="progress-title" id="progressTitle">Uploading...</span>
            <button class="progress-cancel" onclick="cancelProgress()">Cancel</button>
        </div>
        <div class="progress-bar">
            <div class="progress-fill" id="progressFill"></div>
        </div>
        <div class="progress-text">
            <span id="progressPercent">0%</span>
            <span id="progressSize">0 MB / 0 MB</span>
        </div>
        <div class="progress-status" id="progressStatus"></div>
    </div>

    <!-- Background Upload Notification -->
    <div class="bg-upload-notification" id="bgUploadNotification">
        <div class="spinner"></div>
        <span>Uploading in background...</span>
    </div>

    <script>
        let fileStructure = {};
        let currentPath = [];
        let currentImages = [];
        let selectionMode = false;
        let selectedImages = new Set();
        let currentImageIndex = 0;
        let zipFileReader = null;
        let passwordRequired = false;
        let currentPassword = null;
        let modalSwipeHandler = null;
        let abortController = null;

        // Service Worker registration for background upload
        if ('serviceWorker' in navigator) {
            navigator.serviceWorker.register('/sw.js').catch(err => {
                console.log('Service Worker registration failed:', err);
            });
        }

        async function handleZipUpload(event) {
            const file = event.target.files[0];
            if (!file) return;

            showProgress('Uploading', 0);
            abortController = new AbortController();

            try {
                // Simulate chunked upload with progress
                const chunkSize = 1024 * 1024; // 1MB chunks
                let uploaded = 0;

                for (let start = 0; start < file.size; start += chunkSize) {
                    if (abortController.signal.aborted) {
                        throw new Error('Upload cancelled');
                    }

                    const chunk = file.slice(start, Math.min(start + chunkSize, file.size));
                    await new Promise(resolve => setTimeout(resolve, 100)); // Simulate network delay

                    uploaded = Math.min(start + chunkSize, file.size);
                    const percent = (uploaded / file.size) * 100;
                    updateProgress(percent, uploaded, file.size);
                }

                // Process the ZIP file
                updateProgressStatus('Processing ZIP file...');
                await loadZipFile(file);
                
                hideProgress();
            } catch (error) {
                console.error('Upload error:', error);
                hideProgress();
                alert(error.message);
            }

            event.target.value = '';
        }

        async function loadZipFile(file) {
            try {
                const reader = new zip.ZipReader(new zip.BlobReader(file));
                zipFileReader = reader;

                const entries = await reader.getEntries();
                
                // Check if password protected
                if (entries.some(entry => entry.encrypted)) {
                    passwordRequired = true;
                    document.getElementById('passwordForm').classList.add('active');
                    updateProgressStatus('Password required');
                    return;
                }

                await processZipEntries(entries);
            } catch (error) {
                if (error.message.includes('password') || error.message.includes('encrypted')) {
                    passwordRequired = true;
                    document.getElementById('passwordForm').classList.add('active');
                } else {
                    alert('Error loading ZIP file: ' + error.message);
                }
            }
        }

        async function unlockZip() {
            const password = document.getElementById('passwordInput').value;
            if (!password) {
                alert('Please enter a password');
                return;
            }

            currentPassword = password;
            showProgress('Unlocking', 0);

            try {
                const entries = await zipFileReader.getEntries();
                await processZipEntries(entries, password);
                document.getElementById('passwordForm').classList.remove('active');
                document.getElementById('passwordInput').value = '';
                hideProgress();
            } catch (error) {
                hideProgress();
                alert('Invalid password or error unlocking ZIP');
            }
        }

        async function processZipEntries(entries, password = null) {
            fileStructure = {};
            let processedCount = 0;
            const totalEntries = entries.length;

            for (const entry of entries) {
                if (abortController && abortController.signal.aborted) {
                    throw new Error('Processing cancelled');
                }

                if (!entry.directory) {
                    const path = entry.filename.split('/');
                    const fileName = path.pop();

                    if (isImageFile(fileName)) {
                        let current = fileStructure;
                        path.forEach(folder => {
                            if (folder) {
                                if (!current[folder]) {
                                    current[folder] = {};
                                }
                                current = current[folder];
                            }
                        });

                        try {
                            const blob = await entry.getData(
                                new zip.BlobWriter(),
                                password ? { password } : undefined
                            );
                            
                            current[fileName] = {
                                blob: blob,
                                url: URL.createObjectURL(blob),
                                name: fileName,
                                size: entry.uncompressedSize
                            };
                        } catch (error) {
                            console.error('Error extracting file:', fileName, error);
                        }
                    }
                }

                processedCount++;
                const percent = (processedCount / totalEntries) * 100;
                updateProgress(percent, processedCount, totalEntries, 'files');
                updateProgressStatus(`Processing: ${fileName || 'folder'}`);
            }

            await zipFileReader.close();
            renderCurrentView();
        }

        function isImageFile(filename) {
            const ext = filename.toLowerCase().split('.').pop();
            return ['jpg', 'jpeg', 'png', 'gif', 'webp', 'bmp', 'svg'].includes(ext);
        }

        function renderCurrentView() {
            let current = fileStructure;
            currentPath.forEach(folder => {
                current = current[folder];
            });

            renderBreadcrumb();
            renderFolders(current);
            renderImages(current);
            updateEmptyState();
            updateButtons();
        }

        function renderBreadcrumb() {
            const breadcrumb = document.getElementById('breadcrumb');
            let html = '<span class="breadcrumb-item" onclick="navigateTo([])">Home</span>';

            currentPath.forEach((folder, index) => {
                html += '<span class="breadcrumb-separator">‚Ä∫</span>';
                const isLast = index === currentPath.length - 1;
                const path = currentPath.slice(0, index + 1);
                
                if (isLast) {
                    html += `<span class="breadcrumb-item current">${folder}</span>`;
                } else {
                    html += `<span class="breadcrumb-item" onclick='navigateTo(${JSON.stringify(path)})'>${folder}</span>`;
                }
            });

            breadcrumb.innerHTML = html;
        }

        function renderFolders(current) {
            const container = document.getElementById('folderContainer');
            const folders = Object.keys(current).filter(key => typeof current[key] === 'object' && !current[key].blob);

            if (folders.length === 0) {
                container.style.display = 'none';
                return;
            }

            container.style.display = 'flex';
            container.innerHTML = folders.map(folder => 
                `<button class="folder-pill" onclick="navigateToFolder('${folder}')">
                    üìÅ ${folder}
                </button>`
            ).join('');
        }

        function renderImages(current) {
            const grid = document.getElementById('imageGrid');
            const images = Object.keys(current).filter(key => current[key].blob);

            currentImages = images.map(name => ({
                name,
                url: current[name].url,
                blob: current[name].blob,
                size: current[name].size
            }));

            if (images.length === 0) {
                grid.innerHTML = '';
                return;
            }

            grid.innerHTML = currentImages.map((img, index) => 
                `<div class="thumbnail ${selectedImages.has(index) ? 'selected' : ''}" 
                      onclick="handleThumbnailClick(${index})">
                    <img src="${img.url}" alt="${img.name}" loading="lazy">
                    <div class="checkbox">${selectedImages.has(index) ? '‚úì' : ''}</div>
                </div>`
            ).join('');
        }

        function updateEmptyState() {
            const hasContent = Object.keys(fileStructure).length > 0;
            document.getElementById('emptyState').style.display = hasContent ? 'none' : 'block';
            document.getElementById('imageGrid').style.display = hasContent ? 'grid' : 'none';
        }

        function updateButtons() {
            const hasContent = currentImages.length > 0;
            document.getElementById('downloadBtn').disabled = !hasContent;
            document.getElementById('selectBtn').disabled = !hasContent;
        }

        function navigateTo(path) {
            currentPath = path;
            selectedImages.clear();
            selectionMode = false;
            updateSelectionMode();
            renderCurrentView();
        }

        function navigateToFolder(folder) {
            currentPath.push(folder);
            selectedImages.clear();
            selectionMode = false;
            updateSelectionMode();
            renderCurrentView();
        }

        function handleThumbnailClick(index) {
            if (selectionMode) {
                if (selectedImages.has(index)) {
                    selectedImages.delete(index);
                } else {
                    selectedImages.add(index);
                }
                renderImages(getCurrentFolder());
                updateSelectionInfo();
            } else {
                openModal(index);
            }
        }

        function toggleSelection() {
            selectionMode = !selectionMode;
            if (!selectionMode) {
                selectedImages.clear();
            }
            updateSelectionMode();
            renderImages(getCurrentFolder());
        }

        function updateSelectionMode() {
            const grid = document.getElementById('imageGrid');
            const selectBtn = document.getElementById('selectBtn');
            const deleteBtn = document.getElementById('deleteBtn');

            if (selectionMode) {
                grid.classList.add('selection-mode');
                selectBtn.textContent = '‚úï Cancel';
                deleteBtn.style.display = 'flex';
            } else {
                grid.classList.remove('selection-mode');
                selectBtn.textContent = '‚úì Select';
                deleteBtn.style.display = 'none';
            }

            updateSelectionInfo();
        }

        function updateSelectionInfo() {
            const info = document.getElementById('selectionInfo');
            const count = document.getElementById('selectionCount');
            
            if (selectionMode && selectedImages.size > 0) {
                count.textContent = selectedImages.size;
                info.classList.add('active');
            } else {
                info.classList.remove('active');
            }
        }

        function deleteSelected() {
            if (selectedImages.size === 0) return;

            if (!confirm(`Delete ${selectedImages.size} image(s)?`)) return;

            const current = getCurrentFolder();
            const toDelete = Array.from(selectedImages).sort((a, b) => b - a);

            toDelete.forEach(index => {
                const img = currentImages[index];
                URL.revokeObjectURL(img.url);
                delete current[img.name];
            });

            selectedImages.clear();
            selectionMode = false;
            updateSelectionMode();
            renderCurrentView();
        }

        function getCurrentFolder() {
            let current = fileStructure;
            currentPath.forEach(folder => {
                current = current[folder];
            });
            return current;
        }

        async function downloadCurrentFolder() {
            if (currentImages.length === 0) return;

            showProgress('Preparing download', 0);

            try {
                const zipWriter = new zip.ZipWriter(new zip.BlobWriter('application/zip'));
                let processedCount = 0;

                for (const img of currentImages) {
                    if (abortController && abortController.signal.aborted) {
                        throw new Error('Download cancelled');
                    }

                    await zipWriter.add(img.name, new zip.BlobReader(img.blob));
                    processedCount++;
                    
                    const percent = (processedCount / currentImages.length) * 100;
                    updateProgress(percent, processedCount, currentImages.length, 'files');
                    updateProgressStatus(`Adding: ${img.name}`);
                }

                updateProgressStatus('Finalizing ZIP file...');
                const blob = await zipWriter.close();

                const folderName = currentPath.length > 0 ? currentPath[currentPath.length - 1] : 'images';
                const url = URL.createObjectURL(blob);
                const a = document.createElement('a');
                a.href = url;
                a.download = `${folderName}.zip`;
                a.click();
                URL.revokeObjectURL(url);

                hideProgress();
            } catch (error) {
                console.error('Download error:', error);
                hideProgress();
                alert(error.message);
            }
        }

        // Modal functions with swipe support
        function openModal(index) {
            currentImageIndex = index;
            const modal = document.getElementById('imageModal');
            const img = document.getElementById('modalImage');
            const wrapper = document.getElementById('modalImageWrapper');

            img.src = currentImages[index].url;
            document.getElementById('modalImageName').textContent = currentImages[index].name;
            updateModalCounter();

            modal.classList.add('active');
            document.body.style.overflow = 'hidden';

            // Initialize swipe gestures
            initModalSwipe();
        }

        function closeModal() {
            const modal = document.getElementById('imageModal');
            modal.classList.remove('active');
            document.body.style.overflow = '';

            // Destroy swipe handler
            if (modalSwipeHandler) {
                modalSwipeHandler.destroy();
                modalSwipeHandler = null;
            }
        }

        function navigateImage(direction) {
            const newIndex = currentImageIndex + direction;
            if (newIndex >= 0 && newIndex < currentImages.length) {
                currentImageIndex = newIndex;
                const img = document.getElementById('modalImage');
                const wrapper = document.getElementById('modalImageWrapper');

                // Slide animation
                wrapper.style.transform = `translateX(${-direction * 100}px)`;
                wrapper.style.opacity = '0';

                setTimeout(() => {
                    img.src = currentImages[currentImageIndex].url;
                    document.getElementById('modalImageName').textContent = currentImages[currentImageIndex].name;
                    updateModalCounter();

                    wrapper.style.transition = 'none';
                    wrapper.style.transform = `translateX(${direction * 100}px)`;

                    setTimeout(() => {
                        wrapper.style.transition = 'transform 0.3s cubic-bezier(0.4, 0, 0.2, 1), opacity 0.3s ease';
                        wrapper.style.transform = 'translateX(0)';
                        wrapper.style.opacity = '1';
                    }, 50);
                }, 150);
            }
        }

        function updateModalCounter() {
            document.getElementById('modalImageCount').textContent = 
                `${currentImageIndex + 1} / ${currentImages.length}`;

            document.getElementById('prevBtn').disabled = currentImageIndex === 0;
            document.getElementById('nextBtn').disabled = currentImageIndex === currentImages.length - 1;
        }

        function initModalSwipe() {
            const container = document.getElementById('modalImageContainer');
            const wrapper = document.getElementById('modalImageWrapper');

            modalSwipeHandler = new Hammer(container);
            modalSwipeHandler.get('swipe').set({ direction: Hammer.DIRECTION_HORIZONTAL });

            let startX = 0;

            modalSwipeHandler.on('panstart', (e) => {
                wrapper.classList.add('swiping');
                startX = 0;
            });

            modalSwipeHandler.on('panmove', (e) => {
                const deltaX = e.deltaX;
                
                // Prevent swiping beyond boundaries
                if ((currentImageIndex === 0 && deltaX > 0) || 
                    (currentImageIndex === currentImages.length - 1 && deltaX < 0)) {
                    wrapper.style.transform = `translateX(${deltaX * 0.2}px)`;
                } else {
                    wrapper.style.transform = `translateX(${deltaX}px)`;
                }
            });

            modalSwipeHandler.on('panend', (e) => {
                wrapper.classList.remove('swiping');
                const deltaX = e.deltaX;
                const velocity = e.velocityX;

                // Determine if swipe is significant enough
                if (Math.abs(deltaX) > 100 || Math.abs(velocity) > 0.5) {
                    if (deltaX > 0 && currentImageIndex > 0) {
                        navigateImage(-1);
                    } else if (deltaX < 0 && currentImageIndex < currentImages.length - 1) {
                        navigateImage(1);
                    } else {
                        wrapper.style.transform = 'translateX(0)';
                    }
                } else {
                    wrapper.style.transform = 'translateX(0)';
                }
            });

            modalSwipeHandler.on('swipeleft', () => {
                if (currentImageIndex < currentImages.length - 1) {
                    navigateImage(1);
                }
            });

            modalSwipeHandler.on('swiperight', () => {
                if (currentImageIndex > 0) {
                    navigateImage(-1);
                }
            });
        }

        // Progress bar functions
        function showProgress(title, percent) {
            const container = document.getElementById('progressContainer');
            const titleEl = document.getElementById('progressTitle');
            
            titleEl.textContent = title;
            container.classList.add('active');
            updateProgress(percent, 0, 0);
            
            abortController = new AbortController();
        }

        function updateProgress(percent, loaded, total, unit = 'bytes') {
            const fill = document.getElementById('progressFill');
            const percentText = document.getElementById('progressPercent');
            const sizeText = document.getElementById('progressSize');

            fill.style.width = `${Math.min(percent, 100)}%`;
            percentText.textContent = `${Math.round(percent)}%`;

            if (unit === 'bytes') {
                const loadedMB = (loaded / (1024 * 1024)).toFixed(2);
                const totalMB = (total / (1024 * 1024)).toFixed(2);
                sizeText.textContent = `${loadedMB} MB / ${totalMB} MB`;
            } else {
                sizeText.textContent = `${loaded} / ${total} ${unit}`;
            }
        }

        function updateProgressStatus(status) {
            document.getElementById('progressStatus').textContent = status;
        }

        function hideProgress() {
            const container = document.getElementById('progressContainer');
            container.classList.remove('active');
            abortController = null;
        }

        function cancelProgress() {
            if (abortController) {
                abortController.abort();
                hideProgress();
            }
        }

        // Background upload notification
        function showBgUploadNotification() {
            const notification = document.getElementById('bgUploadNotification');
            notification.classList.add('active');

            setTimeout(() => {
                notification.classList.remove('active');
            }, 5000);
        }

        // Keyboard navigation
        document.addEventListener('keydown', (e) => {
            const modal = document.getElementById('imageModal');
            if (!modal.classList.contains('active')) return;

            if (e.key === 'ArrowLeft') {
                navigateImage(-1);
            } else if (e.key === 'ArrowRight') {
                navigateImage(1);
            } else if (e.key === 'Escape') {
                closeModal();
            }
        });

        // Initialize
        updateEmptyState();
    </script>
</body>
</html>
